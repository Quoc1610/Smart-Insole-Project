using System.Collections.Generic;
using UnityEngine;

namespace Kinesis.Core {
    /// <summary>
    /// MuscleTendonUnit implements a multi-segment Hill-type muscle model.
    /// </summary>
    [DisallowMultipleComponent]
    [ExecuteInEditMode]
    public class MuscleTendonUnit : MonoBehaviour {
        /// <summary>
        /// Minimum allowed muscle activation.
        /// </summary>
        public const float MinActivation = 0.0f;
        /// <summary>
        /// Maximum allowed muscle activation.
        /// </summary>
        public const float MaxActivation = 1.0f;
        /// <summary>
        /// Coefficient for calculating maximum muscle velocity (applied to optimal contractile element length).
        /// </summary>
        public const float MaxVelocityFactor = 12.0f;
        /// <summary>
        /// Coefficient that influences force-length curve width. Affects the stiffness of parallel elastic and damping
        /// effects.
        /// </summary>
        public const float WidthFactor = 0.56f;
        /// <summary>
        /// Compression strain factor for calculating passive muscle compression damping effects.
        /// </summary>
        public const float ReferenceCompressionFactor = WidthFactor / 2.0f;
        /// <summary>
        /// Strain when serial elastic force equals maximum isometric contractile force.
        /// </summary>
        public const float ReferenceStrain = 0.033f;
        /// <summary>
        /// Exponent that influences force-length curve broadness.
        /// </summary>
        /// <remarks>
        /// Should be set to an even integer value.
        /// </remarks>
        public const float CurveExponent = 8.0f;
        /// <summary>
        /// Coefficient for modifying force-length response.
        /// </summary>
        public const float C = -2.99573230743408203125f; // Pre-calculated value of Mathf.Log(0.05f).
        /// <summary>
        /// Force-velocity curve shaping factor.
        /// </summary>
        public const float K = 5.0f;
        /// <summary>
        /// Parameter for enhancing force generated during eccentric contraction.
        /// </summary>
        public const float N = 1.5f;

        /// <summary>
        /// Ratio of serial elastic element length to optimal contractile element length (e.g. a value of 1.0 means
        /// the muscle length at rest is 50% serial element and 50% contractile/parallel element).
        /// </summary>
        [Tooltip("Ratio of serial elastic element length to optimal contractile element length.")]
        public float normalizedSEESlackLength = 0.2f;
        /// <summary>
        /// <summary>
        /// Maximum force generated by the contractile element in isometric contraction.
        /// </summary>
        [Tooltip("Maximum force generated by the contractile element.")]
        public float maxIsometricForce = 300.0f;
        /// <summary>
        /// Muscle activation rate (in inverse seconds).
        /// </summary>
        [Tooltip("Muscle activation rate (in inverse seconds).")]
        public float activationConstant = 0.7f;
        /// <summary>
        /// Current muscle activation.
        /// </summary>
        [ReadOnly]
        [Range(MinActivation, MaxActivation)]
        [Tooltip("Current muscle activation.")]
        public float activation = MinActivation;
        [Tooltip("Toggle parallel damping element.")]
        public bool parallelDampingOn = true;
        [Tooltip("Toggle parallel elastic element.")]
        public bool parallelElasticityOn = true;
        [Tooltip("Toggle automatic build of muscle segments.")]
        public bool autoBuildSegments = true;
        /// <summary>
        /// List of muscle "attachment points" that define the muscle's path.
        /// </summary>
        /// <remarks>
        /// Note: Muscle nodes should be ordered from muscle origin toward insertion.
        /// </remarks>
        public List<MuscleNode> muscleNodes;
        /// <summary>
        /// List of muscle segments that comprise the muscle.
        /// </summary>
        /// <remarks>
        /// Note: Muscle segments should be oriented from muscle origin toward insertion.
        /// </remarks>
        public List<MuscleSegment> muscleSegments;
        /// <summary>
        /// Cache of joints spanned by the muscle for convenience.
        /// </summary>
        [HideInNormalInspector]
        public List<Joint> joints;
        /// <summary>
        /// Cache of last joint torque calculation results for convenience.
        /// </summary>
        public Dictionary<MuscleSegment, Vector3> jointTorques;

        /// <summary>
        /// Length at which the contractile element generates maximum force under isometric contraction.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float optimalCELength;
        /// <summary>
        /// Length of the serial elastic element when the muscle is slack/resting.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float seSlackLength;
        /// <summary>
        /// Normalized muscle length where (passive) buffer elasticity beings to kicks in.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float minCELength;
        /// <summary>
        /// Magnitude of the contractile element's maximum contraction velocity.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float maxContractileVelocity;
        /// <summary>
        /// Current contractile element length.
        /// </summary>
        /// <remarks>
        /// Also the length of the [passive] parallel element by definition.
        /// </remarks>
        [ReadOnly]
        [SerializeField]
        private float ceLength;
        /// <summary>
        /// Current serial element length.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float seLength;
        /// <summary>
        /// Current muscle length.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float muscleLength;
        /// <summary>
        /// Normalized serial elastic element force.
        /// </summary>
        [ReadOnly]
        [SerializeField]
        private float normalizedSEEForce;

        /// <summary>
        /// Applies joint torques to target rigid bodies.
        /// </summary>
        /// <param name="jointTorques">
        /// Mapping between muscle segments and joint torque vectors.
        /// </param>
        public static void ApplyJointTorques(in Dictionary<MuscleSegment, Vector3> jointTorques) {
            foreach (KeyValuePair<MuscleSegment, Vector3> kvp in jointTorques) {
                Rigidbody targetRb = kvp.Key.jointAnchorBody;
                Vector3 jointTorque = kvp.Value;
                targetRb.AddTorque(jointTorque);
            }
        }

        /// <summary>
        /// Calculates total muscle length as a sum of muscle segment lengths.
        /// </summary>
        /// <returns>
        /// Total muscle length.
        /// </returns>
        public float MuscleLength() {
            float length = 0.0f;

            for (int tailIndex = 1; tailIndex < this.muscleNodes.Count; tailIndex++) {
                int headIndex = tailIndex - 1;

                MuscleNode head = this.muscleNodes[headIndex];
                MuscleNode tail = this.muscleNodes[tailIndex];

                if (head?.bone == null || tail?.bone == null) {
                    string errorMessage = "Muscle node in muscle " + this + " missing assigned bone.";
                    throw new MuscleNodeMissingBoneException(errorMessage);
                }

                Vector3 tailWorldPosition = tail.bone.transform.TransformPoint(tail.offset);
                Vector3 headWorldPosition = head.bone.transform.TransformPoint(head.offset);

                float segmentLength = Vector3.Distance(tailWorldPosition, headWorldPosition);
                length += segmentLength;
            }

            return length;
        }

        /// <summary>
        /// Generates list of muscle segments from the list of muscle nodes. The list is cached by the object.
        /// </summary>
        public void GenerateMuscleSegments() {
            // Can't generate muscle segment list with less than 2 muscle nodes.
            if (this.muscleNodes.Count < 2) {
                return;
            }

            this.muscleSegments.Clear();
            this.joints.Clear();

            MuscleSegment prevSegment = null;
            for (int tailIndex = 1; tailIndex < this.muscleNodes.Count; tailIndex++) {
                int headIndex = tailIndex - 1;

                MuscleNode head = this.muscleNodes[headIndex];
                MuscleNode tail = this.muscleNodes[tailIndex];

                if (head?.bone == null || tail?.bone == null) {
                    string errorMessage = "Muscle node in muscle " + this + " missing assigned bone.";
                    throw new MuscleNodeMissingBoneException(errorMessage);
                }

                MuscleSegment segment = new MuscleSegment {
                    prevSegment = prevSegment,
                    parentMuscle = this,
                    head = head,
                    tail = tail
                };

                bool isInterbodySegment = head.bone != tail.bone;

                if (isInterbodySegment) {
                    Joint joint = tail.bone.GetComponent<Joint>() ?? head.bone.GetComponent<Joint>();

                    if (joint != null) {
                        Rigidbody jointAnchorBody = joint.gameObject.GetComponent<Rigidbody>();

                        bool hasValidJoint = joint?.connectedBody != null && joint.connectedBody != jointAnchorBody;

                        if (hasValidJoint) {
                            segment.joint = joint;
                            segment.jointAnchorBody = jointAnchorBody;
                            this.joints.Add(joint);
                        }
                    }
                }

                this.muscleSegments.Add(segment);
                prevSegment = segment;
            }
        }

        /// <summary>
        /// (Re)calculates properties that are dependent on other properties.
        /// </summary>
        public void CalculateProperties() {
            float muscleLength = this.MuscleLength();
            float normalizedSEESlackLength = this.normalizedSEESlackLength;
            float optimalCELength = muscleLength / (normalizedSEESlackLength + 1.0f);
            float seSlackLength = muscleLength - optimalCELength;
            float ceLength = optimalCELength;
            float seLength = seSlackLength;
            float seStrain = seLength / seSlackLength - 1.0f;
            float maxContractileVelocity = MaxVelocityFactor * optimalCELength;

            this.muscleLength = muscleLength;
            this.ceLength = ceLength;
            this.seLength = seLength;
            this.optimalCELength = optimalCELength;
            this.seSlackLength = seSlackLength;
            this.minCELength = 1.0f - WidthFactor;
            this.maxContractileVelocity = maxContractileVelocity;
            this.normalizedSEEForce = this.SerialElasticForce(seStrain);

            Mathf.Clamp(this.activation, MinActivation, MaxActivation);
        }

        /// <summary>
        /// Convenience function for both generating muscle segments and calculating properties at once.
        /// </summary>
        public void RefreshProperties() {
            this.GenerateMuscleSegments();
            this.CalculateProperties();
        }

        /// <summary>
        /// Maps contractile element length to a normalized force factor. The force-length factor is used in scaling
        /// muscle force generation.
        /// </summary>
        /// <remarks>
        /// Also called the tenson-length or isometric force function.
        /// </remarks>
        /// <param name="normalizedCELength">
        /// Contractile element length normalized by optimal contractile element length.
        /// </param>
        /// <example>
        /// <c>float normalizedCELength = ceLength / optimalCELength;</c>
        /// <c>float forceLengthFactor = ForceLength(normalizedCELength);</c>
        /// </example>
        /// <returns>
        /// Force-length factor normalized by maximum isometric contraction force.
        /// </returns>
        public float ForceLength(float normalizedCELength) {
            return Mathf.Exp(C * Mathf.Pow(((normalizedCELength - 1.0f) / WidthFactor), CurveExponent));
        }

        /// <summary>
        /// Maps contractile velocity to a normalized force factor. The force-velocity factor is used in scaling muscle
        /// force generation.
        /// </summary>
        /// <param name="normalizedContractileVelocity">
        /// Contractile element velocity normalized by maximum contractile velocity.
        /// </param>
        /// <example>
        /// <c>float normalizedContractileVelocity = muscleVelocity / maxContractileVelocity;</c>
        /// <c>float forceVelocityFactor = ForceVelocity(normalizedCELength);</c>
        /// </example>
        /// <returns>
        /// Force-velocity factor normalized by maximum isometric contraction force.
        /// </returns>
        public float ForceVelocity(float normalizedContractileVelocity) {
            float maxContractileVelocity = this.maxContractileVelocity;

            return (normalizedContractileVelocity < 0.0f)
                ? (maxContractileVelocity - normalizedContractileVelocity) / (maxContractileVelocity + K
                    * normalizedContractileVelocity)
                : (N + (N - 1) * (maxContractileVelocity + normalizedContractileVelocity) / (7.56f * K
                    * normalizedContractileVelocity - maxContractileVelocity));
        }

        /// <summary>
        /// Models the force generated by the contractile element due to muscle contraction.
        /// </summary>
        /// <remarks>
        /// To denormalize the result, multiply by maximum isometric contraction force.
        /// </remarks>
        /// <param name="activation">
        /// Activation value in the unit inverval [0, 1].
        /// </param>
        /// <param name="forceLengthFactor">
        /// Force-length factor (from ForceLength() method).
        /// </param>
        /// <param name="forceVelocityFactor">
        /// Force-velocity factor (from ForceVelocity() method).
        /// </param>
        /// <returns>
        /// Muscle contraction force magnitude normalized by maximum isometric contraction force.
        /// </returns>
        public float ContractileForce(float activation, float forceLengthFactor, float forceVelocityFactor) {
            return activation * forceLengthFactor * forceVelocityFactor;
        }

        /// <summary>
        /// Models the elastic spring force generated by the parallel elastic element when its length (which is the
        /// same as contractile element length by definition) stretches beyond optimum length.
        /// </summary>
        /// <remarks>
        /// To denormalize the result, multiply by maximum isometric contraction force.
        /// </remarks>
        /// <example>
        /// <c>float normalizedCELength = ceLength / optimalCELength;</c>
        /// <c>float normalizedPEEForce = ParallelElasticForce(normalizedCELength);</c>
        /// </example>
        /// <param name="normalizedCELength">
        /// Muscle length normalized by optimal muscle length.
        /// </param>
        /// <returns>
        /// Restoring elastic force normalized by maximum isometric contraction force.
        /// </returns>
        public float ParallelElasticForce(float normalizedCELength) {
            if (normalizedCELength < 1.0f) {
                return 0.0f;
            }

            float c1 = (normalizedCELength - 1.0f) / WidthFactor;
            float parallelElasticForce = c1 * c1;

            return parallelElasticForce;
        }

        /// <summary>
        /// Models the viscous damping force generated by the parallel damping element when its length (which is the
        /// same as contractile element length by definition) compresses below optimum length.
        /// </summary>
        /// <remarks>
        /// To denormalize the result, multiply by maximum isometric contraction force.
        /// </remarks>
        /// <example>
        /// <c>float normalizedCELength = ceLength / optimalCELength;</c>
        /// <c>float parallelDampingForce = ParallelDampingForce(normalizedCELength);</c>
        /// </example>
        /// <param name="normalizedCELength">
        /// Muscle length normalized by optimal muscle length.
        /// </param>
        /// <returns>
        /// Resistive damping force normalized by maximum isometric contraction force.
        /// </returns>
        public float ParallelDampingForce(float normalizedCELength) {
            float minCELength = this.minCELength;

            if (normalizedCELength > minCELength) {
                return 0.0f;
            }

            float c1 = (minCELength - normalizedCELength) / ReferenceCompressionFactor;
            float parallelDampingForce = c1 * c1;

            return parallelDampingForce;
        }

        /// <summary>
        /// Models the elastic spring force generated by the serial elastic element when its length extends beyond
        /// slack length.
        /// </summary>
        /// <remarks>
        /// To denormalize the result value, multiply by the max isometric contraction force.
        /// </remarks>
        /// <example>
        /// <c>float seStrain = this.seLength / this.seSlackLength - 1.0f;</c>
        /// <c>float normalizedSerialElasticForce = this.SerialElasticForce(seStrain);</c>
        /// </example>
        /// <param name="seStrain">
        /// The difference between the serial element's current length and slack length, normalized by the slack
        /// length.
        /// </param>
        /// <returns>
        /// Restoring elastic force normalized by maximum isometric contraction force. Returns zero if the serial
        /// element's current length does not exceed slack length.
        /// </returns>
        public float SerialElasticForce(float seStrain) {
            if (seStrain <= 0.0f) {
                return 0.0f;
            }

            float c1 = seStrain / ReferenceStrain;
            float serialElasticForce = c1 * c1;

            return serialElasticForce;
        }

        /// <summary>
        /// Maps the normalized elastic force generated by a serial elastic element to its strain.
        /// </summary>
        /// <remarks>
        /// A serial element generating zero force experiences no strain. To recover serial element length from strain:
        /// <c>float seLength = (seStrain + 1.0f) * this.seSlackLength;</c>
        /// </remarks>
        /// <param name="normalizedSEEForce">
        /// Serial elastic force normalized by maximum isometric contraction force.
        /// </param>
        /// <returns>
        /// Serial elastic element strain.
        /// </returns>
        public float InverseSerialElasticForce(float normalizedSEEForce) {
            if (normalizedSEEForce < 0.0f) {
                return 0.0f;
            }

            return ReferenceStrain * Mathf.Sqrt(normalizedSEEForce);
        }

        /// <summary>
        /// Transforms a muscle excitation signal into a muscle activation signal.
        /// </summary>
        /// <param name="excitation">
        /// Muscle excitation signal.
        /// </param>
        /// <param name="timesteps">
        /// Number of timesteps to advance.
        /// </param>
        /// <returns>
        /// Muscle activation signal.
        /// </returns>
        public float ActivationDynamics(float excitation, int timesteps = 1) {
            float activation = this.activation;

            if (excitation <= 0.0f && activation <= MinActivation) {
                return MinActivation;
            }

            bool forward = (timesteps >= 0);
            float tau = Time.fixedDeltaTime / this.activationConstant;
            for (int i = 0; i < timesteps; i++) {
                float activationRate = tau * (excitation - activation);
                activation = forward ? activation + activationRate : activation - activationRate;
            }

            return Mathf.Clamp(activation, MinActivation, MaxActivation);
        }

        /// <summary>
        /// Calculates the torques generated for each joint spanned by the muscle.
        /// </summary>
        /// <param name="excitation">
        /// Muscle excitation signal.
        /// </param>
        /// <param name="jointTorques">
        /// Mapping between muscle segments and joint torques. The muscle segment is used as a key instead of the joint
        /// as its wider context provides more convenience and utility.
        /// </param>
        public void CalculateJointTorques(float excitation, ref Dictionary<MuscleSegment, Vector3> jointTorques) {
            // Apply muscle excitation and update muscle activation.
            float activation = this.ActivationDynamics(excitation);
            this.activation = activation;

            float optimalCELength = this.optimalCELength;
            float seSlackLength = this.seSlackLength;
            float maxIsometricForce = this.maxIsometricForce;
            float maxContractileVelocity = this.maxContractileVelocity;
            float muscleLength = this.MuscleLength();
            float prevMuscleLength = this.muscleLength;
            float prevCELength = this.ceLength;
            float prevSELength = this.seLength;
            float muscleVelocity = muscleLength - prevMuscleLength;

            // Calculate serial and contractile element lengths.
            float seStrain = this.InverseSerialElasticForce(this.normalizedSEEForce);
            float seLength = (seStrain + 1.0f) * seSlackLength;
            float ceLength = muscleLength - seLength;

            // Component length should not exceed total muscle length.
            if (ceLength > muscleLength) {
                string errorMsg = "Contractile element length exceeds total muscle length.";
                throw new MuscleComponentLengthException(errorMsg);
            } else if (seLength > muscleLength) {
                string errorMsg = "Serial element length exceeds total muscle length.";
                throw new MuscleComponentLengthException(errorMsg);
            }

            // Calculate remaining basic contractile parameters.
            float contractileVelocity = ceLength - prevCELength;
            float normalizedCELength = ceLength / optimalCELength;
            float normalizedContractileVelocity = contractileVelocity / maxContractileVelocity;

            // Calculate normalized contractile force of active muscle elements.
            float forceLengthFactor = this.ForceLength(normalizedCELength);
            float forceVelocityFactor = this.ForceVelocity(normalizedContractileVelocity);
            float normalizedCEForce = this.ContractileForce(activation, forceLengthFactor, forceVelocityFactor);

            // Calculate normalized contractile force of passive muscle elements.
            float normalizedPEEForce = this.parallelElasticityOn
                ? this.ParallelElasticForce(normalizedCELength)
                : 0.0f;
            float normalizedPDEForce = this.parallelDampingOn ? this.ParallelDampingForce(normalizedCELength) : 0.0f;
            float normalizedPEForce = normalizedPEEForce - normalizedPDEForce;

            // Calculate normalized SEE force.
            float normalizedSEEForce = normalizedCEForce + normalizedPEForce;

            // Set muscle force to denormalized SEE force.
            float muscleForce = maxIsometricForce * normalizedSEEForce;

            // Update muscle state.
            this.ceLength = ceLength;
            this.muscleLength = muscleLength;
            this.normalizedSEEForce = normalizedSEEForce;

            // Generate torque for each joint in the muscle.
            jointTorques.Clear();
            foreach (MuscleSegment currentSegment in this.muscleSegments) {
                if (currentSegment.joint == null) {
                    continue;
                }

                // Calculate muscle force vector.
                Vector3 headPosition = currentSegment.head.bone.transform.TransformPoint(currentSegment.head.offset);
                Vector3 tailPosition = currentSegment.tail.bone.transform.TransformPoint(currentSegment.tail.offset);
                // Muscle force line of action is from the tail of the segment toward the head.
                Vector3 forceUnitVector = (headPosition - tailPosition).normalized;

                // Calculate joint torque.
                // Caveat: Remember that Unity uses a left-handed coordinate system.
                Vector3 jointPosition = currentSegment.joint.transform.TransformPoint(currentSegment.joint.anchor);
                Vector3 leverArm = tailPosition - jointPosition;
                Vector3 torqueVector = Vector3.Cross(leverArm, forceUnitVector);
                Vector3 jointTorque = muscleForce * torqueVector;

                jointTorques[currentSegment] = jointTorque;
            }

            // Cache calculated joint torque results.
            this.jointTorques = jointTorques;
        }

        void OnValidate() {
            this.CalculateProperties();
        }

        void Reset() {
            this.muscleNodes = new List<MuscleNode>();
            this.muscleSegments = new List<MuscleSegment>();
            this.joints = new List<Joint>();

            this.RefreshProperties();
        }
    }
}